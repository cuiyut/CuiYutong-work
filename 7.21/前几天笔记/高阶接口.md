**索引类型**

​	1）绕开多余属性时，[]中间的内容是可变的

​	2）数组模式：如果想要东西不可被修改，只能读取，那么就使用readonly



**接口继承**（extends）

​	1）减少了代码量、提高额接口的可复用性，一个接口可以继承多个，用逗号隔开

​	2）①原型链法：问题--当原型中存在引用类型值时，实例可以修改其值

​		②仅继承父构造函数的原型对象：优点：1.不需要新建对象实例

​																			2.不需要遍历原型链

​																缺点：子对象的修改会影响到父对象

​		③借用构造函数：可以解决原型中引用类型值被修改的问题

​							缺点：1.只能继承父实例属性和方法，不能继承父原型属性和方法

​										2.无法实现函数复用

​		④组合继承：优点：1.可以复用原型上定义的方法

​						2.保证每个函数有自己的属性，解决原型中引用类型值被修改的问题

​		⑤原型式继承：缺点：原型中引用类型值会被修改、无法传递参数

​		⑥寄生式继承：在原型式继承的基础上，通过封装继承过程的函数增强对象，返回对象

​		⑦寄生组合式继承

​		⑧Class继承



**闭包**

​	1）外部函数不能访问内部函数的作用域，内部函数可以访问外部函数

​	2）闭包可以形成一个块级作用域，用来保存变量

​	3）可以隔离作用域，避免全局污染，但是容易导致内存泄露

​	4）闭包的返回值必须式一个回调函数



**混合类型接口**

​	1）js类型式灵活的，函数是对象类型，对象里也可以有属性，也就是说有时一个对象既是函数，也包含一些属性

​	2）好处：变量永久保存，不会被污染

​					变量只是内部使用

​					可以定义每个类型，方便维护



**构造函数**

​	1）构造函数本质上是个普通函数，充当类的角色，主要用来创建实例，并初始化实例，即为实例成员变量赋初始值

​	2）普通函数是直接调用，而构造函数需要使用 `new` 关键字来进行调用

​	3）如果想要使用显式的返回值，则显式的返回值必须是对象



**原型**

​	1）原型就是每个构造函数都有prototype属性，指向另一个对象，所有对象都有一个proto属性，指向构造函数的prototype原型对象

​	2）作用就是让同一个方法在内存中只有一份，节省空间，优化性能



**原型链**

​	万物皆对象

​	原型链就是访问一个对象时，先查找这个对象自身有没有该属性，没有就找原型，还没有就找原型对象的原型，一直到object为止



**栈和堆**

​	1）栈存放基本数据类型

​	2）堆存放复杂数据类型

​	3）栈先进先出，堆先进后出