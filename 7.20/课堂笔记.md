**枚举**

**1.数字枚举**

​	可以像访问对象一样使用 ‘，’ 和 ’ [] ‘

​	格式：名字1.名字2、名字1[ ’名字2‘ ]

​	索引值固定一个后，后面的如果没定义就依次递增

​	可以使用常量和计算值，如果一个值使用了计算值和常量，就要给每一个进行赋值

​	某个位置使用了计算值就不能默认递增了



**2.反向映射**

​	只支持数字类型  ---> 名字1[定义的数字]



**3.字符串枚举**

​	字符串值成员的枚举中不能使用计算值，且必须是字符串

​	必须要有初始化·表达式



**4.异构枚举**（最好不要用）

​	就是既有字符串也有数字或者多个类型结合的枚举



**5.枚举类型**

​	可以把符合条件的成员作为枚举值来使用



**6.联合枚举**

​	当枚举值符合条件的时候，这个成员可以看做是包含所有成员的联合类型



**7.运行时的枚举**

​	枚举编译后的值实际时一个对象



**8.const枚举类型**

​	将代码抽离出去，不需要编译后的对象，省时省力





**interface**

​	定义函数需要传的参数较多的时候，可以用到interface



**可选属性**

​	格式：属性名 ?：类型

​	那么这个参数就可传可不传



**多余属性**

​	格式：[prop：string]：any



**多余属性检查**

​	如果没有这个属性就会报错没有这个属性



**绕开多余属性检查**

​	1）使用类型断言 as <>

​	2）使用多余属性 [prop：string]：any

​	3）利用类型兼容性



**只读属性**（readonly）

​	1）使用const修改常量里的属性会报错

​	2）使用const定义一个对象，修改对象里面属性不会报错，如果需要对象里的属性不可以修改，就使用readonly



**函数类型**

​	1）接口能描述普通对象，也可以描述函数类型

​	2）定义函数的时候，名字可以和接口中参数中的额名可以不相同，但位置要一致



